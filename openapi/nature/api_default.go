/*
Nature API

Read/Write Nature Remo

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiCall1ApplianceOrdersPostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	appliances *string
}

// List of all appliances&#39; IDs comma separated
func (r ApiCall1ApplianceOrdersPostRequest) Appliances(appliances string) ApiCall1ApplianceOrdersPostRequest {
	r.appliances = &appliances
	return r
}

func (r ApiCall1ApplianceOrdersPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.Call1ApplianceOrdersPostExecute(r)
}

/*
Call1ApplianceOrdersPost Method for Call1ApplianceOrdersPost

Reorder appliances.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCall1ApplianceOrdersPostRequest
*/
func (a *DefaultApiService) Call1ApplianceOrdersPost(ctx context.Context) ApiCall1ApplianceOrdersPostRequest {
	return ApiCall1ApplianceOrdersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) Call1ApplianceOrdersPostExecute(r ApiCall1ApplianceOrdersPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1ApplianceOrdersPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/appliance_orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appliances == nil {
		return nil, reportError("appliances is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("appliances", parameterToString(*r.appliances, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCall1AppliancesApplianceAirconSettingsPostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	appliance string
	temperature *string
	operationMode *string
	airVolume *string
	airDirection *string
	button *string
}

// Temperature
func (r ApiCall1AppliancesApplianceAirconSettingsPostRequest) Temperature(temperature string) ApiCall1AppliancesApplianceAirconSettingsPostRequest {
	r.temperature = &temperature
	return r
}
// AC operation mode
func (r ApiCall1AppliancesApplianceAirconSettingsPostRequest) OperationMode(operationMode string) ApiCall1AppliancesApplianceAirconSettingsPostRequest {
	r.operationMode = &operationMode
	return r
}
// AC air volume
func (r ApiCall1AppliancesApplianceAirconSettingsPostRequest) AirVolume(airVolume string) ApiCall1AppliancesApplianceAirconSettingsPostRequest {
	r.airVolume = &airVolume
	return r
}
// AC air direction
func (r ApiCall1AppliancesApplianceAirconSettingsPostRequest) AirDirection(airDirection string) ApiCall1AppliancesApplianceAirconSettingsPostRequest {
	r.airDirection = &airDirection
	return r
}
// Button
func (r ApiCall1AppliancesApplianceAirconSettingsPostRequest) Button(button string) ApiCall1AppliancesApplianceAirconSettingsPostRequest {
	r.button = &button
	return r
}

func (r ApiCall1AppliancesApplianceAirconSettingsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.Call1AppliancesApplianceAirconSettingsPostExecute(r)
}

/*
Call1AppliancesApplianceAirconSettingsPost Method for Call1AppliancesApplianceAirconSettingsPost

Update air conditioner settings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appliance Appliance ID.
 @return ApiCall1AppliancesApplianceAirconSettingsPostRequest
*/
func (a *DefaultApiService) Call1AppliancesApplianceAirconSettingsPost(ctx context.Context, appliance string) ApiCall1AppliancesApplianceAirconSettingsPostRequest {
	return ApiCall1AppliancesApplianceAirconSettingsPostRequest{
		ApiService: a,
		ctx: ctx,
		appliance: appliance,
	}
}

// Execute executes the request
func (a *DefaultApiService) Call1AppliancesApplianceAirconSettingsPostExecute(r ApiCall1AppliancesApplianceAirconSettingsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1AppliancesApplianceAirconSettingsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/appliances/{appliance}/aircon_settings"
	localVarPath = strings.Replace(localVarPath, "{"+"appliance"+"}", url.PathEscape(parameterToString(r.appliance, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.temperature != nil {
		localVarFormParams.Add("temperature", parameterToString(*r.temperature, ""))
	}
	if r.operationMode != nil {
		localVarFormParams.Add("operation_mode", parameterToString(*r.operationMode, ""))
	}
	if r.airVolume != nil {
		localVarFormParams.Add("air_volume", parameterToString(*r.airVolume, ""))
	}
	if r.airDirection != nil {
		localVarFormParams.Add("air_direction", parameterToString(*r.airDirection, ""))
	}
	if r.button != nil {
		localVarFormParams.Add("button", parameterToString(*r.button, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCall1AppliancesApplianceDeletePostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	appliance string
}


func (r ApiCall1AppliancesApplianceDeletePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.Call1AppliancesApplianceDeletePostExecute(r)
}

/*
Call1AppliancesApplianceDeletePost Method for Call1AppliancesApplianceDeletePost

Delete appliance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appliance Appliance ID.
 @return ApiCall1AppliancesApplianceDeletePostRequest
*/
func (a *DefaultApiService) Call1AppliancesApplianceDeletePost(ctx context.Context, appliance string) ApiCall1AppliancesApplianceDeletePostRequest {
	return ApiCall1AppliancesApplianceDeletePostRequest{
		ApiService: a,
		ctx: ctx,
		appliance: appliance,
	}
}

// Execute executes the request
func (a *DefaultApiService) Call1AppliancesApplianceDeletePostExecute(r ApiCall1AppliancesApplianceDeletePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1AppliancesApplianceDeletePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/appliances/{appliance}/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"appliance"+"}", url.PathEscape(parameterToString(r.appliance, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCall1AppliancesApplianceLightPostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	appliance string
	button *string
}

// Button name
func (r ApiCall1AppliancesApplianceLightPostRequest) Button(button string) ApiCall1AppliancesApplianceLightPostRequest {
	r.button = &button
	return r
}

func (r ApiCall1AppliancesApplianceLightPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.Call1AppliancesApplianceLightPostExecute(r)
}

/*
Call1AppliancesApplianceLightPost Method for Call1AppliancesApplianceLightPost

Send light infrared signal.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appliance Appliance ID.
 @return ApiCall1AppliancesApplianceLightPostRequest
*/
func (a *DefaultApiService) Call1AppliancesApplianceLightPost(ctx context.Context, appliance string) ApiCall1AppliancesApplianceLightPostRequest {
	return ApiCall1AppliancesApplianceLightPostRequest{
		ApiService: a,
		ctx: ctx,
		appliance: appliance,
	}
}

// Execute executes the request
func (a *DefaultApiService) Call1AppliancesApplianceLightPostExecute(r ApiCall1AppliancesApplianceLightPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1AppliancesApplianceLightPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/appliances/{appliance}/light"
	localVarPath = strings.Replace(localVarPath, "{"+"appliance"+"}", url.PathEscape(parameterToString(r.appliance, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.button == nil {
		return nil, reportError("button is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("button", parameterToString(*r.button, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCall1AppliancesAppliancePostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	appliance string
	image *string
	nickname *string
}

// Basename of the image file included in the app. Ex: \\\&quot;ico_ac_1\\\&quot; 
func (r ApiCall1AppliancesAppliancePostRequest) Image(image string) ApiCall1AppliancesAppliancePostRequest {
	r.image = &image
	return r
}
// Appliance name
func (r ApiCall1AppliancesAppliancePostRequest) Nickname(nickname string) ApiCall1AppliancesAppliancePostRequest {
	r.nickname = &nickname
	return r
}

func (r ApiCall1AppliancesAppliancePostRequest) Execute() (*Appliance, *http.Response, error) {
	return r.ApiService.Call1AppliancesAppliancePostExecute(r)
}

/*
Call1AppliancesAppliancePost Method for Call1AppliancesAppliancePost

Update appliance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appliance Appliance ID.
 @return ApiCall1AppliancesAppliancePostRequest
*/
func (a *DefaultApiService) Call1AppliancesAppliancePost(ctx context.Context, appliance string) ApiCall1AppliancesAppliancePostRequest {
	return ApiCall1AppliancesAppliancePostRequest{
		ApiService: a,
		ctx: ctx,
		appliance: appliance,
	}
}

// Execute executes the request
//  @return Appliance
func (a *DefaultApiService) Call1AppliancesAppliancePostExecute(r ApiCall1AppliancesAppliancePostRequest) (*Appliance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Appliance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1AppliancesAppliancePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/appliances/{appliance}"
	localVarPath = strings.Replace(localVarPath, "{"+"appliance"+"}", url.PathEscape(parameterToString(r.appliance, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.image == nil {
		return localVarReturnValue, nil, reportError("image is required and must be specified")
	}
	if r.nickname == nil {
		return localVarReturnValue, nil, reportError("nickname is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("image", parameterToString(*r.image, ""))
	localVarFormParams.Add("nickname", parameterToString(*r.nickname, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCall1AppliancesApplianceSignalOrdersPostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	appliance string
	signals *string
}

// List of all signals&#39; IDs comma separated
func (r ApiCall1AppliancesApplianceSignalOrdersPostRequest) Signals(signals string) ApiCall1AppliancesApplianceSignalOrdersPostRequest {
	r.signals = &signals
	return r
}

func (r ApiCall1AppliancesApplianceSignalOrdersPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.Call1AppliancesApplianceSignalOrdersPostExecute(r)
}

/*
Call1AppliancesApplianceSignalOrdersPost Method for Call1AppliancesApplianceSignalOrdersPost

Reorder signals under this appliance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appliance Appliance ID.
 @return ApiCall1AppliancesApplianceSignalOrdersPostRequest
*/
func (a *DefaultApiService) Call1AppliancesApplianceSignalOrdersPost(ctx context.Context, appliance string) ApiCall1AppliancesApplianceSignalOrdersPostRequest {
	return ApiCall1AppliancesApplianceSignalOrdersPostRequest{
		ApiService: a,
		ctx: ctx,
		appliance: appliance,
	}
}

// Execute executes the request
func (a *DefaultApiService) Call1AppliancesApplianceSignalOrdersPostExecute(r ApiCall1AppliancesApplianceSignalOrdersPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1AppliancesApplianceSignalOrdersPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/appliances/{appliance}/signal_orders"
	localVarPath = strings.Replace(localVarPath, "{"+"appliance"+"}", url.PathEscape(parameterToString(r.appliance, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.signals == nil {
		return nil, reportError("signals is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("signals", parameterToString(*r.signals, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCall1AppliancesApplianceSignalsGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	appliance string
}


func (r ApiCall1AppliancesApplianceSignalsGetRequest) Execute() ([]Signal, *http.Response, error) {
	return r.ApiService.Call1AppliancesApplianceSignalsGetExecute(r)
}

/*
Call1AppliancesApplianceSignalsGet Method for Call1AppliancesApplianceSignalsGet

Fetch signals registered under this appliance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appliance Appliance ID.
 @return ApiCall1AppliancesApplianceSignalsGetRequest
*/
func (a *DefaultApiService) Call1AppliancesApplianceSignalsGet(ctx context.Context, appliance string) ApiCall1AppliancesApplianceSignalsGetRequest {
	return ApiCall1AppliancesApplianceSignalsGetRequest{
		ApiService: a,
		ctx: ctx,
		appliance: appliance,
	}
}

// Execute executes the request
//  @return []Signal
func (a *DefaultApiService) Call1AppliancesApplianceSignalsGetExecute(r ApiCall1AppliancesApplianceSignalsGetRequest) ([]Signal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Signal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1AppliancesApplianceSignalsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/appliances/{appliance}/signals"
	localVarPath = strings.Replace(localVarPath, "{"+"appliance"+"}", url.PathEscape(parameterToString(r.appliance, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCall1AppliancesApplianceSignalsPostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	appliance string
	message *string
	image *string
	name *string
}

// JSON serialized object describing infrared signals. Includes \\\&quot;data\\\&quot;, \\\&quot;freq\\\&quot; and \\\&quot;format\\\&quot; keys.
func (r ApiCall1AppliancesApplianceSignalsPostRequest) Message(message string) ApiCall1AppliancesApplianceSignalsPostRequest {
	r.message = &message
	return r
}
// Basename of the image file included in the app. Ex: \\\&quot;ico_io\\\&quot; 
func (r ApiCall1AppliancesApplianceSignalsPostRequest) Image(image string) ApiCall1AppliancesApplianceSignalsPostRequest {
	r.image = &image
	return r
}
// Signal name
func (r ApiCall1AppliancesApplianceSignalsPostRequest) Name(name string) ApiCall1AppliancesApplianceSignalsPostRequest {
	r.name = &name
	return r
}

func (r ApiCall1AppliancesApplianceSignalsPostRequest) Execute() (*Signal, *http.Response, error) {
	return r.ApiService.Call1AppliancesApplianceSignalsPostExecute(r)
}

/*
Call1AppliancesApplianceSignalsPost Method for Call1AppliancesApplianceSignalsPost

Create a signal under this appliance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appliance Appliance ID.
 @return ApiCall1AppliancesApplianceSignalsPostRequest
*/
func (a *DefaultApiService) Call1AppliancesApplianceSignalsPost(ctx context.Context, appliance string) ApiCall1AppliancesApplianceSignalsPostRequest {
	return ApiCall1AppliancesApplianceSignalsPostRequest{
		ApiService: a,
		ctx: ctx,
		appliance: appliance,
	}
}

// Execute executes the request
//  @return Signal
func (a *DefaultApiService) Call1AppliancesApplianceSignalsPostExecute(r ApiCall1AppliancesApplianceSignalsPostRequest) (*Signal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Signal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1AppliancesApplianceSignalsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/appliances/{appliance}/signals"
	localVarPath = strings.Replace(localVarPath, "{"+"appliance"+"}", url.PathEscape(parameterToString(r.appliance, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.message == nil {
		return localVarReturnValue, nil, reportError("message is required and must be specified")
	}
	if r.image == nil {
		return localVarReturnValue, nil, reportError("image is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("message", parameterToString(*r.message, ""))
	localVarFormParams.Add("image", parameterToString(*r.image, ""))
	localVarFormParams.Add("name", parameterToString(*r.name, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCall1AppliancesApplianceTvPostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	appliance string
	button *string
}

// Button name
func (r ApiCall1AppliancesApplianceTvPostRequest) Button(button string) ApiCall1AppliancesApplianceTvPostRequest {
	r.button = &button
	return r
}

func (r ApiCall1AppliancesApplianceTvPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.Call1AppliancesApplianceTvPostExecute(r)
}

/*
Call1AppliancesApplianceTvPost Method for Call1AppliancesApplianceTvPost

Send tv infrared signal.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appliance Appliance ID.
 @return ApiCall1AppliancesApplianceTvPostRequest
*/
func (a *DefaultApiService) Call1AppliancesApplianceTvPost(ctx context.Context, appliance string) ApiCall1AppliancesApplianceTvPostRequest {
	return ApiCall1AppliancesApplianceTvPostRequest{
		ApiService: a,
		ctx: ctx,
		appliance: appliance,
	}
}

// Execute executes the request
func (a *DefaultApiService) Call1AppliancesApplianceTvPostExecute(r ApiCall1AppliancesApplianceTvPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1AppliancesApplianceTvPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/appliances/{appliance}/tv"
	localVarPath = strings.Replace(localVarPath, "{"+"appliance"+"}", url.PathEscape(parameterToString(r.appliance, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.button == nil {
		return nil, reportError("button is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("button", parameterToString(*r.button, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCall1AppliancesGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
}


func (r ApiCall1AppliancesGetRequest) Execute() ([]Appliance, *http.Response, error) {
	return r.ApiService.Call1AppliancesGetExecute(r)
}

/*
Call1AppliancesGet Method for Call1AppliancesGet

Fetch the list of appliances.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCall1AppliancesGetRequest
*/
func (a *DefaultApiService) Call1AppliancesGet(ctx context.Context) ApiCall1AppliancesGetRequest {
	return ApiCall1AppliancesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Appliance
func (a *DefaultApiService) Call1AppliancesGetExecute(r ApiCall1AppliancesGetRequest) ([]Appliance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Appliance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1AppliancesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/appliances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCall1AppliancesPostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	nickname *string
	device *string
	image *string
	model *string
	modelType *string
}

// Appliance name
func (r ApiCall1AppliancesPostRequest) Nickname(nickname string) ApiCall1AppliancesPostRequest {
	r.nickname = &nickname
	return r
}
// Device ID
func (r ApiCall1AppliancesPostRequest) Device(device string) ApiCall1AppliancesPostRequest {
	r.device = &device
	return r
}
// Basename of the image file included in the app. Ex: \\\&quot;ico_ac_1\\\&quot; 
func (r ApiCall1AppliancesPostRequest) Image(image string) ApiCall1AppliancesPostRequest {
	r.image = &image
	return r
}
// ApplianceModel ID if the appliance we&#39;re trying to create is included in IRDB.
func (r ApiCall1AppliancesPostRequest) Model(model string) ApiCall1AppliancesPostRequest {
	r.model = &model
	return r
}
func (r ApiCall1AppliancesPostRequest) ModelType(modelType string) ApiCall1AppliancesPostRequest {
	r.modelType = &modelType
	return r
}

func (r ApiCall1AppliancesPostRequest) Execute() (*Appliance, *http.Response, error) {
	return r.ApiService.Call1AppliancesPostExecute(r)
}

/*
Call1AppliancesPost Method for Call1AppliancesPost

Create a new appliance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCall1AppliancesPostRequest
*/
func (a *DefaultApiService) Call1AppliancesPost(ctx context.Context) ApiCall1AppliancesPostRequest {
	return ApiCall1AppliancesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Appliance
func (a *DefaultApiService) Call1AppliancesPostExecute(r ApiCall1AppliancesPostRequest) (*Appliance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Appliance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1AppliancesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/appliances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nickname == nil {
		return localVarReturnValue, nil, reportError("nickname is required and must be specified")
	}
	if r.device == nil {
		return localVarReturnValue, nil, reportError("device is required and must be specified")
	}
	if r.image == nil {
		return localVarReturnValue, nil, reportError("image is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("nickname", parameterToString(*r.nickname, ""))
	if r.model != nil {
		localVarFormParams.Add("model", parameterToString(*r.model, ""))
	}
	if r.modelType != nil {
		localVarFormParams.Add("model_type", parameterToString(*r.modelType, ""))
	}
	localVarFormParams.Add("device", parameterToString(*r.device, ""))
	localVarFormParams.Add("image", parameterToString(*r.image, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCall1DetectappliancePostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	message *string
}

// JSON serialized object describing infrared signals. Includes \\\&quot;data\\\&quot;, \\\&quot;freq\\\&quot; and \\\&quot;format\\\&quot; keys.
func (r ApiCall1DetectappliancePostRequest) Message(message string) ApiCall1DetectappliancePostRequest {
	r.message = &message
	return r
}

func (r ApiCall1DetectappliancePostRequest) Execute() ([]ApplianceModelAndParam, *http.Response, error) {
	return r.ApiService.Call1DetectappliancePostExecute(r)
}

/*
Call1DetectappliancePost Method for Call1DetectappliancePost

Find the air conditioner best matching the provided infrared signal.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCall1DetectappliancePostRequest
*/
func (a *DefaultApiService) Call1DetectappliancePost(ctx context.Context) ApiCall1DetectappliancePostRequest {
	return ApiCall1DetectappliancePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ApplianceModelAndParam
func (a *DefaultApiService) Call1DetectappliancePostExecute(r ApiCall1DetectappliancePostRequest) ([]ApplianceModelAndParam, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApplianceModelAndParam
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1DetectappliancePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/detectappliance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.message == nil {
		return localVarReturnValue, nil, reportError("message is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("message", parameterToString(*r.message, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCall1DevicesDeviceDeletePostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	device string
}


func (r ApiCall1DevicesDeviceDeletePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.Call1DevicesDeviceDeletePostExecute(r)
}

/*
Call1DevicesDeviceDeletePost Method for Call1DevicesDeviceDeletePost

Delete Remo.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param device Device ID.
 @return ApiCall1DevicesDeviceDeletePostRequest
*/
func (a *DefaultApiService) Call1DevicesDeviceDeletePost(ctx context.Context, device string) ApiCall1DevicesDeviceDeletePostRequest {
	return ApiCall1DevicesDeviceDeletePostRequest{
		ApiService: a,
		ctx: ctx,
		device: device,
	}
}

// Execute executes the request
func (a *DefaultApiService) Call1DevicesDeviceDeletePostExecute(r ApiCall1DevicesDeviceDeletePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1DevicesDeviceDeletePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/devices/{device}/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"device"+"}", url.PathEscape(parameterToString(r.device, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCall1DevicesDeviceHumidityOffsetPostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	device string
	offset *int32
}

// Humidity offset value added to the measured humidity.
func (r ApiCall1DevicesDeviceHumidityOffsetPostRequest) Offset(offset int32) ApiCall1DevicesDeviceHumidityOffsetPostRequest {
	r.offset = &offset
	return r
}

func (r ApiCall1DevicesDeviceHumidityOffsetPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.Call1DevicesDeviceHumidityOffsetPostExecute(r)
}

/*
Call1DevicesDeviceHumidityOffsetPost Method for Call1DevicesDeviceHumidityOffsetPost

Update humidity offset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param device Device ID.
 @return ApiCall1DevicesDeviceHumidityOffsetPostRequest
*/
func (a *DefaultApiService) Call1DevicesDeviceHumidityOffsetPost(ctx context.Context, device string) ApiCall1DevicesDeviceHumidityOffsetPostRequest {
	return ApiCall1DevicesDeviceHumidityOffsetPostRequest{
		ApiService: a,
		ctx: ctx,
		device: device,
	}
}

// Execute executes the request
func (a *DefaultApiService) Call1DevicesDeviceHumidityOffsetPostExecute(r ApiCall1DevicesDeviceHumidityOffsetPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1DevicesDeviceHumidityOffsetPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/devices/{device}/humidity_offset"
	localVarPath = strings.Replace(localVarPath, "{"+"device"+"}", url.PathEscape(parameterToString(r.device, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.offset == nil {
		return nil, reportError("offset is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("offset", parameterToString(*r.offset, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCall1DevicesDevicePostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	device string
	name *string
}

// Signal name
func (r ApiCall1DevicesDevicePostRequest) Name(name string) ApiCall1DevicesDevicePostRequest {
	r.name = &name
	return r
}

func (r ApiCall1DevicesDevicePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.Call1DevicesDevicePostExecute(r)
}

/*
Call1DevicesDevicePost Method for Call1DevicesDevicePost

Update Remo

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param device Device ID.
 @return ApiCall1DevicesDevicePostRequest
*/
func (a *DefaultApiService) Call1DevicesDevicePost(ctx context.Context, device string) ApiCall1DevicesDevicePostRequest {
	return ApiCall1DevicesDevicePostRequest{
		ApiService: a,
		ctx: ctx,
		device: device,
	}
}

// Execute executes the request
func (a *DefaultApiService) Call1DevicesDevicePostExecute(r ApiCall1DevicesDevicePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1DevicesDevicePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/devices/{device}"
	localVarPath = strings.Replace(localVarPath, "{"+"device"+"}", url.PathEscape(parameterToString(r.device, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return nil, reportError("name is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(*r.name, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCall1DevicesDeviceTemperatureOffsetPostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	device string
	offset *int32
}

// Temperature offset value added to the measured temperature.
func (r ApiCall1DevicesDeviceTemperatureOffsetPostRequest) Offset(offset int32) ApiCall1DevicesDeviceTemperatureOffsetPostRequest {
	r.offset = &offset
	return r
}

func (r ApiCall1DevicesDeviceTemperatureOffsetPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.Call1DevicesDeviceTemperatureOffsetPostExecute(r)
}

/*
Call1DevicesDeviceTemperatureOffsetPost Method for Call1DevicesDeviceTemperatureOffsetPost

Update temperature offset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param device Device ID.
 @return ApiCall1DevicesDeviceTemperatureOffsetPostRequest
*/
func (a *DefaultApiService) Call1DevicesDeviceTemperatureOffsetPost(ctx context.Context, device string) ApiCall1DevicesDeviceTemperatureOffsetPostRequest {
	return ApiCall1DevicesDeviceTemperatureOffsetPostRequest{
		ApiService: a,
		ctx: ctx,
		device: device,
	}
}

// Execute executes the request
func (a *DefaultApiService) Call1DevicesDeviceTemperatureOffsetPostExecute(r ApiCall1DevicesDeviceTemperatureOffsetPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1DevicesDeviceTemperatureOffsetPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/devices/{device}/temperature_offset"
	localVarPath = strings.Replace(localVarPath, "{"+"device"+"}", url.PathEscape(parameterToString(r.device, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.offset == nil {
		return nil, reportError("offset is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("offset", parameterToString(*r.offset, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCall1DevicesGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
}


func (r ApiCall1DevicesGetRequest) Execute() ([]Device, *http.Response, error) {
	return r.ApiService.Call1DevicesGetExecute(r)
}

/*
Call1DevicesGet Method for Call1DevicesGet

Fetch the list of Remo devices the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCall1DevicesGetRequest
*/
func (a *DefaultApiService) Call1DevicesGet(ctx context.Context) ApiCall1DevicesGetRequest {
	return ApiCall1DevicesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Device
func (a *DefaultApiService) Call1DevicesGetExecute(r ApiCall1DevicesGetRequest) ([]Device, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1DevicesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCall1SignalsSignalDeletePostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	signal string
}


func (r ApiCall1SignalsSignalDeletePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.Call1SignalsSignalDeletePostExecute(r)
}

/*
Call1SignalsSignalDeletePost Method for Call1SignalsSignalDeletePost

Delete an infrared signal.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signal Signal ID.
 @return ApiCall1SignalsSignalDeletePostRequest
*/
func (a *DefaultApiService) Call1SignalsSignalDeletePost(ctx context.Context, signal string) ApiCall1SignalsSignalDeletePostRequest {
	return ApiCall1SignalsSignalDeletePostRequest{
		ApiService: a,
		ctx: ctx,
		signal: signal,
	}
}

// Execute executes the request
func (a *DefaultApiService) Call1SignalsSignalDeletePostExecute(r ApiCall1SignalsSignalDeletePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1SignalsSignalDeletePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/signals/{signal}/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"signal"+"}", url.PathEscape(parameterToString(r.signal, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCall1SignalsSignalPostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	signal string
	image *string
	name *string
}

// Basename of the image file included in the app. Ex: \\\&quot;ico_io\\\&quot; 
func (r ApiCall1SignalsSignalPostRequest) Image(image string) ApiCall1SignalsSignalPostRequest {
	r.image = &image
	return r
}
// Signal name
func (r ApiCall1SignalsSignalPostRequest) Name(name string) ApiCall1SignalsSignalPostRequest {
	r.name = &name
	return r
}

func (r ApiCall1SignalsSignalPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.Call1SignalsSignalPostExecute(r)
}

/*
Call1SignalsSignalPost Method for Call1SignalsSignalPost

Update infrared signal.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signal Signal ID.
 @return ApiCall1SignalsSignalPostRequest
*/
func (a *DefaultApiService) Call1SignalsSignalPost(ctx context.Context, signal string) ApiCall1SignalsSignalPostRequest {
	return ApiCall1SignalsSignalPostRequest{
		ApiService: a,
		ctx: ctx,
		signal: signal,
	}
}

// Execute executes the request
func (a *DefaultApiService) Call1SignalsSignalPostExecute(r ApiCall1SignalsSignalPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1SignalsSignalPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/signals/{signal}"
	localVarPath = strings.Replace(localVarPath, "{"+"signal"+"}", url.PathEscape(parameterToString(r.signal, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.image == nil {
		return nil, reportError("image is required and must be specified")
	}
	if r.name == nil {
		return nil, reportError("name is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("image", parameterToString(*r.image, ""))
	localVarFormParams.Add("name", parameterToString(*r.name, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCall1SignalsSignalSendPostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	signal string
}


func (r ApiCall1SignalsSignalSendPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.Call1SignalsSignalSendPostExecute(r)
}

/*
Call1SignalsSignalSendPost Method for Call1SignalsSignalSendPost

Send infrared signal.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signal Signal ID.
 @return ApiCall1SignalsSignalSendPostRequest
*/
func (a *DefaultApiService) Call1SignalsSignalSendPost(ctx context.Context, signal string) ApiCall1SignalsSignalSendPostRequest {
	return ApiCall1SignalsSignalSendPostRequest{
		ApiService: a,
		ctx: ctx,
		signal: signal,
	}
}

// Execute executes the request
func (a *DefaultApiService) Call1SignalsSignalSendPostExecute(r ApiCall1SignalsSignalSendPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1SignalsSignalSendPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/signals/{signal}/send"
	localVarPath = strings.Replace(localVarPath, "{"+"signal"+"}", url.PathEscape(parameterToString(r.signal, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCall1UsersMeGetRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
}


func (r ApiCall1UsersMeGetRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.Call1UsersMeGetExecute(r)
}

/*
Call1UsersMeGet Method for Call1UsersMeGet

Fetch the authenticated user's information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCall1UsersMeGetRequest
*/
func (a *DefaultApiService) Call1UsersMeGet(ctx context.Context) ApiCall1UsersMeGetRequest {
	return ApiCall1UsersMeGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return User
func (a *DefaultApiService) Call1UsersMeGetExecute(r ApiCall1UsersMeGetRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1UsersMeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/users/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCall1UsersMePostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	nickname *string
}

// User&#39;s nickname. 
func (r ApiCall1UsersMePostRequest) Nickname(nickname string) ApiCall1UsersMePostRequest {
	r.nickname = &nickname
	return r
}

func (r ApiCall1UsersMePostRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.Call1UsersMePostExecute(r)
}

/*
Call1UsersMePost Method for Call1UsersMePost

Update authenticated user's information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCall1UsersMePostRequest
*/
func (a *DefaultApiService) Call1UsersMePost(ctx context.Context) ApiCall1UsersMePostRequest {
	return ApiCall1UsersMePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return User
func (a *DefaultApiService) Call1UsersMePostExecute(r ApiCall1UsersMePostRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Call1UsersMePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/users/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nickname == nil {
		return localVarReturnValue, nil, reportError("nickname is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("nickname", parameterToString(*r.nickname, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
